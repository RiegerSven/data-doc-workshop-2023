# Import and merge data

```{r}
#| label: read-data-imp
#| echo: false
#| warning: false

exDat <- readRDS("exampleDat.RDS")

```

This part provides an introduction to import data sets into `R` and merge them. 

```{css, echo=FALSE}
.vScrollbar {
  max-height: 250px;
  overflow-y: scroll;
}
```

## Import (or export) data sets

In `R` data sets are usually stored as `data.frame` objects (see also the section [Data Structures](intro-r-rstudio.qmd#data-structure)). There are other object types for data sets such as `tibble` from the `tibble` package [@R-tibble] or `data.table` from the `data.table` package [@R-data.table] which are more efficient, especially when it comes to (very) large data sets (see e.g., [Chapter 10](https://r4ds.had.co.nz/tibbles.html) of [R for Data Science](https://r4ds.had.co.nz/) and the [vignette](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html) of the `data.table` package).

### Data frames

Data sets can come in many different file formats. For example, `.txt`, `.csv` files, or `.sav` ([SPSS](https://www.ibm.com/spss)), `dta` ([Stata](https://www.stata.com/)), `.sas7bdat` ([SAS](https://www.sas.com/en_us/home.html)) files.

To import e.g., `.csv` or `.txt` files, `R` offers a couple of functions that deal with these formats:

- `utils::read.table`: Reads a file in table format and creates a data frame from it, with cases corresponding to lines and variables to fields in the file.
    - `utils::read.csv` or `utils::read.csv2`^[see also here: <https://stackoverflow.com/questions/22970091/difference-between-read-csv-and-read-csv2-in-r>]
    - `utils::read.delim` or `utils::read.delim2` 

- `base::readLines`: Read some or all text lines from a connection.

- ...

When it comes to other (software specific) formats, you need additional packages e.g., `foreign` [@R-foreign] or `haven` [@R-haven]. 

To import the SPSS data sets (`.sav` file), we may use the `read.spss` function from the `foreign` package [@R-foreign]. There are a couple of default arguments which you (likely) want to change:

- `use.value.labels`: logical: convert variables with value labels into R factors with those levels? (default is `TRUE` switch to `FALSE`)
- `to.data.frame`logical: return a data frame? (default is `FALSE` switch to `TRUE`)
- `use.missings`: logical: should information on user-defined missing values be used to set the corresponding values to NA?

```{r}
#| label: demo-read-spss
#| eval: false
#| code-fold: false

exDatImpforeign <- foreign::read.spss("path-to-file.sav-file",
                                      use.value.labels = FALSE,
                                      to.data.frame = TRUE,
                                      use.missings = TRUE)

```

::: {.callout-note collapse="true" appearance="simple"}
## Exporting dataframes

To export data to a file, you can use the `base::write` function(s):

- `utils::write.table`
- `utils::write.csv` or `utils::write.csv2`
- ...

Again, when it comes to software-specific file formats you need additional packages such as `foreign` [@R-foreign] or `haven` [@R-haven]:

- `haven::write_sav`
- `foreign::write.foreign`
- ...


In the following, the use of the `write.foreign` function is displayed:

```{r}
#| label: demo-write-foreign
#| eval: false
#| code-fold: false 


getwd()
codefile <- tempfile()

foreign::write.foreign(exDat,
                       "exDat.sav",
                       codefile = codefile,
                       package = c("SPSS"))

unlink(codefile)
```

Note that there are a couple of further steps necessary to get a working `.sav` file. We recommend using the `haven` [@R-haven] package (see [below]()), at least when it comes to exporting data sets.

::: 

### Tibbles

The tibble package is part of the `tidyverse`^[for more see the section on [Base R ~~vs.~~ & tidyverse](intro-r-rstudio.qmd#baseR-tidyverse).] [@R-tidyverse].

First, check the class of the example data set `exDat`.

```{r}
#| label: class-exDat
#| code-fold: false
class(exDat)
```
The `as_tibble` function from the `tibble` package [@R-tibble] turns an existing object (a data frame or matrix) into `tibble` which is a `data.frame` variant (with nice defaults)  and `class` `tbl_df` (see `?tibble::as_tibble`).


```{r}
#| label: demo-as-tibble
#| code-fold: false
exDatTib <- tibble::as_tibble(exDat)
class(exDatTib)
```

The `write_sav` function from the `haven` package [@R-haven] can also be used to export data sets. Before exporting the data, you may want to check your working directory with the `getwd()` function.

```{r}
#| label: demo-write-sav
#| eval: false
#| code-fold: false 


getwd()
haven::write_sav(exDat, "exDat.sav")

```

To import the data set, we use the `read_sav` function from the `haven` package.

```{r}
#| label: demo-read-sav
#| eval: false
#| code-fold: false

exDatImpTest <- haven::read_sav("exDat.sav")

```

Note that the `read_sav` returns a `tibble`, `data.frame` variant (with nice defaults).

For more see <https://tibble.tidyverse.org/> and [Chapter 10](https://r4ds.had.co.nz/tibbles.html) of [R for Data Science](https://r4ds.had.co.nz/).

## Merge data sets

Merging data sets is necessary, because we often work with different data sources. By merging, we combine the information from multiple data sets to create one (complete) data set.



::: {.callout-note collapse="false" appearance="simple" title="Before we merge, we need another data set. Execute the following code to simulate one!"}

```{r}
#| label: sim-merge
#| code-fold: false
PopModMerge <- "
eta2 =~ .8*gsc1 + .8*gsc2 + .8*gsc3 + .8*gsc4
eta2 ~~ 1*eta2
eta2 ~ 0*1

gsc1 | -1.5*t1 + 0*t2 + 1.5*t3
gsc2 | -1.5*t1 + 0*t2 + 1.5*t3
gsc3 | 1.5*t1 + 0*t2 + -1.5*t3
gsc4 | 1.5*t1 + 0*t2 + -1.5*t3

"

exDatMerge <- lavaan::simulateData(model = PopModMerge,
                                   sample.nobs = 700,
                                   seed = 999)
exDatMerge$id <- 1:nrow(exDatMerge)
```

:::

::: {.panel-tabset}

### base R

The `merge` function is designed to merge two data frames by common columns or row names, or do other versions of database join operations. It requires at least two `input` arguments `x`,`y` that are `data frames`, or `objects` to be coerced to one. However, it is recommended to provide some more information by using the further `input` arguments, including:

- `by`, `by.x`, `by.y`: specifications of the columns used for merging. See ‘Details’.

- `all`: logical; `all` = L is shorthand for `all.x` = L and `all.y` = L, where L is either `TRUE` or `FALSE`.

- `all.x`: logical; if `TRUE`, then extra rows will be added to the output, one for each row in `x` that has no matching row in `y`. These rows will have `NAs` in those columns that are usually filled with values from `y`. The default is `FALSE`, so that only rows with data from both x and y are included in the output.

- `all.y`: logical; analogous to `all.x`.

- ...


```{r}
#| label: demo-merge
exDatComb <- merge(exDat, exDatMerge,
                   by = "id",
                   all.x = TRUE)
head(exDatComb)
```

### dplyr package

In the `dplyr` packages, there are 4 functions that are designed to combine data sets which need two input arguments `x` and `y`:

1. `dplyr::left_join` keeps all observations in x.

2. `dplyr::right_join` keeps all observations in y.

3. `dplyr::inner_join` only keeps observations from x that have a matching key in y.

4. `dplyr::full_join` keeps all observations in x and y.

It is recommended to use the `by` argument to specify the column(s) that are used for joining/merging. 

```{r}
#| label: demo-left-join-dplyr
exDat |>
  dplyr::left_join(exDatMerge, by = "id") |>
  head()
```

:::